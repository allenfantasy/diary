<!DOCTYPE html><!--[if lte IE 8]>
<html lang="en" class="lte-ie8">
<![endif]-->
<!--[if gt IE 8]><!-->
<html lang="en">
<!--<![endif]--><head><meta charset="utf-8"><title>February 9, 2016</title><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/diary/styles/global.css"><link rel="stylesheet" href="/diary/styles/tomorrow.css"><link rel="stylesheet" href="/diary/styles/diary.css"></head><body><header class="header"><div class="index"><a href="/diary/">Index</a></div><h1>February 9, 2016</h1></header><div class="content"><div class="diary"><h2 id="quote">Quote</h2>
<blockquote>
<p>A little learning is a dangerous thing. -- Alexander Pope</p>
</blockquote>
<h2 id="weekly-picks">Weekly Picks</h2>
<p>These are the picks from 2016.2.3 - 2.9</p>
<h3 id="techs">Techs</h3>
<ul>
<li><a href="https://github.com/substack/psy">psy</a> - 类似 PM2 但简单一点的工具, by @substack （试用了之后还是喜欢 PM2 多一点）</li>
<li><a href="http://brunch.io/">Brunch</a> - WTF! it seems the one I need.</li>
<li><a href="https://github.com/phoenixlzx/the_start.md">The Start</a> - 强文。新手必读。强推。by @phoenixlzx</li>
<li><a href="http://translations.readthedocs.org/en/latest/hacker_howto.html">如何成为一名黑客</a> - 也是一篇必读的文章</li>
<li><a href="https://github.com/sotayamashita/awesome-css">Awesome CSS</a></li>
<li><a href="https://github.com/jobbole/awesome-css-cn">Awesome CSS 中文</a></li>
<li><a href="http://book.douban.com/subject/3709579/">大教堂与市集</a> - by Eric Raymond (a.k.a ESR)</li>
</ul>
<h3 id="misc">Misc</h3>
<ul>
<li><a href="http://paulmillr.com/posts/the-story-of-telegram/">The story of Telegram or “Why you shouldn’t listen to Hacker News”</a></li>
<li><a href="http://www.pingwest.com/fighting-with-fun/">亲自参加两岸Facebook“表情包大战”是一种什么样的体验</a> A interesting article from <em>Pingwest</em></li>
</ul>
<h2 id="closure-in-15-lines">Closure in 15 lines</h2>
<p>Reference: <a href="http://stackoverflow.com/questions/111102/how-do-javascript-closures-work">How do JavaScript Closure Work</a></p>
<p>A closure is the local variables for a function - kept alive after the function has returned.</p>
<p>In JavaScript, if you use the <code>function</code> keyword inside another function, you are creating a closure.</p>
<p>The magic is that in JavaScript a function reference also has <strong>a secret reference to the closure</strong> it was created in — similar to how delegates are a method pointer plus a secret reference to an object.</p>
<p>There is a closure for <strong>each call</strong> to a function.</p>
<pre><code class="lang-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">addFactory</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">var</span> c = <span class="hljs-number">0</span>;
  <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-built_in">console</span>.log(c++);
  }
}
<span class="hljs-keyword">var</span> add = addFactory();
add(); <span class="hljs-comment">// =&gt; 0</span>
add(); <span class="hljs-comment">// =&gt; 1</span>
</code></pre>
<h3 id="quiz">Quiz</h3>
<p>Can you tell what would be printed in this snippet?</p>
<pre><code class="lang-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">buildList</span>(<span class="hljs-params">list</span>) </span>{
  <span class="hljs-keyword">var</span> result = [];
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; list.length; i++) {
    <span class="hljs-keyword">var</span> item = <span class="hljs-string">'item'</span> + i;
    result.push( <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{<span class="hljs-built_in">console</span>.log(item + <span class="hljs-string">' '</span> + list[i])} );
  }
  <span class="hljs-keyword">return</span> result;
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">testList</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">var</span> fnList = buildList([<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>]);
  <span class="hljs-comment">// Using j only to help prevent confusion -- could use i.</span>
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> j = <span class="hljs-number">0</span>; j &lt; fnList.length; j++) {
    fnList[j]();
  }
}
testList();
</code></pre>
<h3 id="a-chinese-summary-">A Chinese Summary:</h3>
<ol>
<li>closure 的生成条件：在一个函数内声明另一个函数。我们称外面的那个函数叫「外层函数」，里面声明的叫「内层函数」。</li>
<li>closure 的生成方式：「外层函数」通过某种方式将「内层函数」暴露给外部（注意，不一定是返回值，也可以是外层函数外面的某个变量引用内层函数）</li>
<li>closure 的本质：就是「内层函数」对象对「外层函数」里某些变量的引用。
在「外层函数」里声明的变量，本来应该会在「外层函数」执行后被 GC 回收，但因为变量被「内层函数」所引用了，所以 GC 不会去销毁这个对象 ==&gt; 所以我们可以通过暴露出来的「内层函数」，来获得对这些变量的控制权。</li>
</ol>
</div></div><footer class="footer"><address class="author">Copyright &copy;<a rel="author" href="https://github.com/allenfantasy" class="author-name">Allen Wu</a>-<a href="https://github.com/allenfantasy/my-tech-diary" class="source-repo">Source</a></address><p>Generated by<a href="https://github.com/joyeecheung/diary" class="site-repo">Joyee Cheung&#39;s diary generator</a></p></footer></body></html>